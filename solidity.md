# Solidity

Created: January 15, 2022 8:37 PM
Updated: May 28, 2022 1:12 PM

CHEATSHEETS

[solidity.pdf](Solidity%203774f21d2ab54e6ba9d538b82b53fdca/solidity.pdf)

[Ethereum](Ethereum%208996bbb067934c9fa33663dddde6d1ab.md) 

[Solidity by Example](https://solidity-by-example.org/)

SOLIDITY

- 3 types of variables
    - Local
        - Declared inside a function and are not stored on blockchain
    - State
        - declared outside a function to maintain the state of the smart contract
        - Stored on the blockchain
        - State variable values are stored in contract storage permanently.
        - Additionally, you can specify the visibility of a state variable as:
            - **public:** part of the contract interface and can be accessed from other contracts.
            - **internal:** only accessed internally from the current contract.
            - **private:** only visible for the contract they're defined in.
    - Global
        - Provide information about the blockchain. They are injected by the Ethereum Virtual Machine during runtime.
        - Includes things like transaction sender, block timestamp, block hash, etc.
        
        MISC
        
    - EVM for short. It's a sandboxed environment that is completely isolated. It doesn't access anything else on the network besides the contracts it executes.
    - Always make sure to include the latest version of Solidity
    - memory - the value is stored only in memory, and not on the blockchain
                  it only exists during the time the function is being executed
    - Solidity does not support floating numbers(decimals)
        - **`ERC20`** tokens by default work with 18 decimal places. So 1 full **`LW3Token`** in this case, is actually represented as **`10 ^ 18`**. Therefore, to get 10 full **`LW3Tokens`**, we use **`10 * 10 ** 18`**.
        - 1 token = 10 ** 18
        - 10 tokens = 10 * 10 ** 18
    - Provider: Eth node that reads for you
    - Signer: Eth node that reads and writes for you
    - ABI: When you compile your Solidity code, an ABI is automatically generated by the compiler. It contains rules and metadata about functions present in the contract, which help in doing the proper data conversion back and forth.
    - accepting payments in ERC20 tokens is not as simple as just making a function **`payable`**
     in Solidity.
        - •  you cannot *send* ERC20 tokens along with a function call, like you can do with ETH
        - Approval & transfer
            - internally, you approve an allowance limit that the contract can pull from your account in exchange for whatever.
    

```solidity
// BASICS

// Declares verision range
pragma solidity >0.7.0 <0.8.0;
// Declares any version greater than
pragma solidity ^0.8.0

contract ContractName {}
contract ContractName as ERC20 {}

function buy() public {}
function buy(uint price) public returns (uint)
 { //returns an integer }

// DECLARE NUMBER, INTEGERS, ETC.
uint8 public u8 = 10;
uint256 public u256 = 600;
uint public u = 1230; // uint is an alias for uint256
int public i = -123; // int is same as int256, accepts negative #'s

// ADDRESS
address public addr = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c;

// BOOLEAN
bool public defaultBoo1 = false;

// USING GLOBALS BLOCK & MSG
/*
block.timestamp tells us whats the timestamp for the current block
msg.sender tells us wich address called the doSomething function
*/
uint timestamp = block.timestamp; // Current block timestamp
address sender = msg.sender; // address of the caller

// A special symbol _; to indicate where the function body gets inserted.
```

```solidity

// ARRAYS
// can have fixed or dynamic sizes

uint[] public arr;
uint[] public arr2 = [1, 2, 3];
    // Fixed sized array, all elements initialize to 0
uint[10] public myFixedSizeArr;

/* 
Solidity can return the entire array.

Here the array is only needed for the duration while the function executes and thus is declared as a memory variable
*/
function getArr(uint[] memory _arr) public view returns (uint[] memory) {
    return _arr;
}

// Append to array
// This will increase the array length by 1.
arr.push(i);
// Remove last element from array
// This will decrease the array length by 1
arr.pop();
// get the length of the array
uint length = arr.length;
// Delete does not change the array length.
// It resets the value at index to it's default value,
// in this case 0
delete arr[index];
// create array in memory, only fixed size can be created
uint[] memory a = new uint[](5);
// create string in memory
string memory hi = "hi";

```

```solidity
// SOLIDITY OOP

// inheritance (extends ERC20 class/module)
contract Name is ERC20 {}

// extending ERC20 gives the contract a double constructor, one for each object
constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}
```

```solidity
// ERC20

// internal function, can only be called by ERC20 contract
_mint(addressToMintTo, amountOfTokens)
```

```solidity
// FUNCTIONS

function buy() public {}
function buy(uint price) public returns (uint)
 { //returns an integer }

/*
- Functions can use one of the following visibility specifiers: **public**, **private**, **internal**, and **external**.
- Other function modifiers that can be used in the function definition are:
    - **pure** to describe functions that don't allow modifications or access of state.
    - **view** to describe functions that don't allow modifications of state.
    - **payable** to describe functions that can receive Ether. 

Getter functions (those which return values) can be declared either **`view`** or **`pure`**.

- **`View`**: Functions which do not change any state values
- **`Pure`**: Functions which do not change any state values, but also don't read any state values
*/

// MODIFIERS
// Specify function uses the "onlySeller" modifer. 
// "_;" runs the function body
// They are commonly used for restricting access to certain functions, validing input parameters, protecting against certain types of attacks, etc.

address public seller;

modifier onlySeller() {
    require(
        msg.sender == seller,
        "Only seller can put an item up for sale."
    );
    _;
}

function listItem() public view onlySeller {
    // ...
}

//Other function modifiers that can be used in the function definition are:

pure to describe functions that don't allow modifications or access of state.
view to describe functions that don't allow modifications of state.
payable to describe functions that can receive Ether.

internal only this contract and derivatives can access
external can only be accessed from outside
public can be accessed by all contracts
private can only be accessed from this contract;

constant disallows assignment

function (param types) {internal|external} [pure|constant|view|payable] [returns (return types)] varName;

// Transfer ETH
// out of contract
call
//receive into a contract
receive() external payable
fallback() external payable
// receive() is called if msg.data is an empty value, and fallback() is used otherwise.
```

```solidity
// EVENTS
// They are commonly used to allow frontend interfaces to listen for specific events and update the user interface, or used as a cheap form of storage.

contract Marketplace {
    event PurchasedItem(address buyer, uint price);

    function buy() public {
        // ...
        emit PurchasedItem(msg.sender, msg.value);
    }
}

// To call an event, you must use the keyword emit with the event name and its parameters.
```

```solidity
// ETHERS.js

// getContractFacgtory is an abstraction for deploying
const nftContract = await ethers.getContractFactory("GameItem");

ethers.deploy() // deploy
Contract.address // address
```

```solidity
// MAPPINGS
// Mapping always returns a value.

mapping (keyType => valueType)

// examples
mapping(address  => uint) public myMap;

// can be nested
mapping(address => mapping(uint => bool)) public nestedMap;

```

```solidity
// ENUMs

enum Status {
        Pending,
        Shipped,
        Accepted,
        Rejected,
        Canceled
    }

// Declare a variable of the type Status
    // This can only contain one of the predefined values
    Status public status;

// Since enums are internally represented by uints
    // This function will always return a uint
    // Pending = 0
    // Shipped = 1 etc.

// Update a member
function cancel() public {
        status = Status.Canceled; // Will set status = 4
    }
```

```solidity
// STRUCTs

// user defined data types, similar grouped together

// Declare a struct which groups together two data types
    struct TodoItem {
        string text;
        bool completed;
    }
    
    // Create an array of TodoItem structs
    TodoItem[] public todos;

    function createTodo(string memory _text) public {
        // There are multiple ways to initialize structs
        
        // Method 1 - Call it like a function
        todos.push(TodoItem(_text, false));
        
        // Method 2 - Explicitly set its keys
        todos.push(TodoItem({ text: _text, completed: false }));
        
        // Method 3 - Initialize an empty struct, then set individual properties
        TodoItem memory todo;
        todo.text = _text;
        todo.completed = false;
        todos.push(todo);
    }
    
    // Update a struct value
    function update(uint _index, string memory _text) public {
        todos[_index].text = _text;
    }

```

```jsx
// OOP

// Inheritance
/* A parent contract which has a function that can be overridden by a child contract must be declared as a virtual function. */

contract A {
    // Declare a virtual function foo() which can be overridden by children
    function foo() public pure virtual returns (string memory) {
        return "A";
    }
}

/*
A child contrant that is going to override a parent function must use the override keyword.

The order of inheritance matters if parent contracts share methods or attributes by the same name. */

contract B is A {
    // Override A.foo();
    // But also allow this function to be overridden by further children
    // So we specify both keywords - virtual and override
    function foo() public pure virtual override returns (string memory) {
        return "B";
    }
}

// When inheriting from multiple contracts, if a function is defined multiple times, the right-most parent contract's function is used.
contract D is B, C {
    // D.foo() returns "C"
    // since C is the right-most parent with function foo();
    // override (B,C) means we want to override a method that exists in two parents
    function foo() public pure override (B, C) returns (string memory) {
        // super is a special keyword that is used to call functions
        // in the parent contract
        return super.foo();

```

```jsx
// INTERFACEs

// Note: Interfaces you use do not need to be extensive. i.e. they do not need to necessarily contain all the functions that exist in the external contract - only those which you might be calling at some point.

interface MinimalERC20 {
    // Just include the functions we are interested in
    // in the interface
    function balanceOf(address account) external view returns (uint256);
}

```